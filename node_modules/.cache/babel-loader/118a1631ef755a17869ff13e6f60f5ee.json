{"ast":null,"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n'use strict';\n\nvar EventPluginHub = require('./EventPluginHub');\n\nvar EventPluginUtils = require('./EventPluginUtils');\n\nvar accumulateInto = require('./accumulateInto');\n\nvar forEachAccumulated = require('./forEachAccumulated');\n\nvar warning = require('fbjs/lib/warning');\n\nvar getListener = EventPluginHub.getListener;\n/**\n * Some event types have a notion of different registration names for different\n * \"phases\" of propagation. This finds listeners by a given phase.\n */\n\nfunction listenerAtPhase(inst, event, propagationPhase) {\n  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];\n  return getListener(inst, registrationName);\n}\n/**\n * Tags a `SyntheticEvent` with dispatched listeners. Creating this function\n * here, allows us to not have to bind or create functions for each event.\n * Mutating the event's members allows us to not have to create a wrapping\n * \"dispatch\" object that pairs the event with the listener.\n */\n\n\nfunction accumulateDirectionalDispatches(inst, phase, event) {\n  if (process.env.NODE_ENV !== 'production') {\n    process.env.NODE_ENV !== 'production' ? warning(inst, 'Dispatching inst must not be null') : void 0;\n  }\n\n  var listener = listenerAtPhase(inst, event, phase);\n\n  if (listener) {\n    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n  }\n}\n/**\n * Collect dispatches (must be entirely collected before dispatching - see unit\n * tests). Lazily allocate the array to conserve memory.  We must loop through\n * each event and perform the traversal for each one. We cannot perform a\n * single traversal for the entire collection of events because each event may\n * have a different target.\n */\n\n\nfunction accumulateTwoPhaseDispatchesSingle(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    EventPluginUtils.traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);\n  }\n}\n/**\n * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.\n */\n\n\nfunction accumulateTwoPhaseDispatchesSingleSkipTarget(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    var targetInst = event._targetInst;\n    var parentInst = targetInst ? EventPluginUtils.getParentInstance(targetInst) : null;\n    EventPluginUtils.traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);\n  }\n}\n/**\n * Accumulates without regard to direction, does not look for phased\n * registration names. Same as `accumulateDirectDispatchesSingle` but without\n * requiring that the `dispatchMarker` be the same as the dispatched ID.\n */\n\n\nfunction accumulateDispatches(inst, ignoredDirection, event) {\n  if (event && event.dispatchConfig.registrationName) {\n    var registrationName = event.dispatchConfig.registrationName;\n    var listener = getListener(inst, registrationName);\n\n    if (listener) {\n      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n    }\n  }\n}\n/**\n * Accumulates dispatches on an `SyntheticEvent`, but only for the\n * `dispatchMarker`.\n * @param {SyntheticEvent} event\n */\n\n\nfunction accumulateDirectDispatchesSingle(event) {\n  if (event && event.dispatchConfig.registrationName) {\n    accumulateDispatches(event._targetInst, null, event);\n  }\n}\n\nfunction accumulateTwoPhaseDispatches(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);\n}\n\nfunction accumulateTwoPhaseDispatchesSkipTarget(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);\n}\n\nfunction accumulateEnterLeaveDispatches(leave, enter, from, to) {\n  EventPluginUtils.traverseEnterLeave(from, to, accumulateDispatches, leave, enter);\n}\n\nfunction accumulateDirectDispatches(events) {\n  forEachAccumulated(events, accumulateDirectDispatchesSingle);\n}\n/**\n * A small set of propagation patterns, each of which will accept a small amount\n * of information, and generate a set of \"dispatch ready event objects\" - which\n * are sets of events that have already been annotated with a set of dispatched\n * listener functions/ids. The API is designed this way to discourage these\n * propagation strategies from actually executing the dispatches, since we\n * always want to collect the entire set of dispatches before executing event a\n * single one.\n *\n * @constructor EventPropagators\n */\n\n\nvar EventPropagators = {\n  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,\n  accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,\n  accumulateDirectDispatches: accumulateDirectDispatches,\n  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches\n};\nmodule.exports = EventPropagators;","map":{"version":3,"names":["EventPluginHub","require","EventPluginUtils","accumulateInto","forEachAccumulated","warning","getListener","listenerAtPhase","inst","event","propagationPhase","registrationName","dispatchConfig","phasedRegistrationNames","accumulateDirectionalDispatches","phase","process","env","NODE_ENV","listener","_dispatchListeners","_dispatchInstances","accumulateTwoPhaseDispatchesSingle","traverseTwoPhase","_targetInst","accumulateTwoPhaseDispatchesSingleSkipTarget","targetInst","parentInst","getParentInstance","accumulateDispatches","ignoredDirection","accumulateDirectDispatchesSingle","accumulateTwoPhaseDispatches","events","accumulateTwoPhaseDispatchesSkipTarget","accumulateEnterLeaveDispatches","leave","enter","from","to","traverseEnterLeave","accumulateDirectDispatches","EventPropagators","module","exports"],"sources":["C:/Users/putha/node_modules/react-dom/lib/EventPropagators.js"],"sourcesContent":["/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nvar EventPluginHub = require('./EventPluginHub');\nvar EventPluginUtils = require('./EventPluginUtils');\n\nvar accumulateInto = require('./accumulateInto');\nvar forEachAccumulated = require('./forEachAccumulated');\nvar warning = require('fbjs/lib/warning');\n\nvar getListener = EventPluginHub.getListener;\n\n/**\n * Some event types have a notion of different registration names for different\n * \"phases\" of propagation. This finds listeners by a given phase.\n */\nfunction listenerAtPhase(inst, event, propagationPhase) {\n  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];\n  return getListener(inst, registrationName);\n}\n\n/**\n * Tags a `SyntheticEvent` with dispatched listeners. Creating this function\n * here, allows us to not have to bind or create functions for each event.\n * Mutating the event's members allows us to not have to create a wrapping\n * \"dispatch\" object that pairs the event with the listener.\n */\nfunction accumulateDirectionalDispatches(inst, phase, event) {\n  if (process.env.NODE_ENV !== 'production') {\n    process.env.NODE_ENV !== 'production' ? warning(inst, 'Dispatching inst must not be null') : void 0;\n  }\n  var listener = listenerAtPhase(inst, event, phase);\n  if (listener) {\n    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n  }\n}\n\n/**\n * Collect dispatches (must be entirely collected before dispatching - see unit\n * tests). Lazily allocate the array to conserve memory.  We must loop through\n * each event and perform the traversal for each one. We cannot perform a\n * single traversal for the entire collection of events because each event may\n * have a different target.\n */\nfunction accumulateTwoPhaseDispatchesSingle(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    EventPluginUtils.traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);\n  }\n}\n\n/**\n * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.\n */\nfunction accumulateTwoPhaseDispatchesSingleSkipTarget(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    var targetInst = event._targetInst;\n    var parentInst = targetInst ? EventPluginUtils.getParentInstance(targetInst) : null;\n    EventPluginUtils.traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);\n  }\n}\n\n/**\n * Accumulates without regard to direction, does not look for phased\n * registration names. Same as `accumulateDirectDispatchesSingle` but without\n * requiring that the `dispatchMarker` be the same as the dispatched ID.\n */\nfunction accumulateDispatches(inst, ignoredDirection, event) {\n  if (event && event.dispatchConfig.registrationName) {\n    var registrationName = event.dispatchConfig.registrationName;\n    var listener = getListener(inst, registrationName);\n    if (listener) {\n      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n    }\n  }\n}\n\n/**\n * Accumulates dispatches on an `SyntheticEvent`, but only for the\n * `dispatchMarker`.\n * @param {SyntheticEvent} event\n */\nfunction accumulateDirectDispatchesSingle(event) {\n  if (event && event.dispatchConfig.registrationName) {\n    accumulateDispatches(event._targetInst, null, event);\n  }\n}\n\nfunction accumulateTwoPhaseDispatches(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);\n}\n\nfunction accumulateTwoPhaseDispatchesSkipTarget(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);\n}\n\nfunction accumulateEnterLeaveDispatches(leave, enter, from, to) {\n  EventPluginUtils.traverseEnterLeave(from, to, accumulateDispatches, leave, enter);\n}\n\nfunction accumulateDirectDispatches(events) {\n  forEachAccumulated(events, accumulateDirectDispatchesSingle);\n}\n\n/**\n * A small set of propagation patterns, each of which will accept a small amount\n * of information, and generate a set of \"dispatch ready event objects\" - which\n * are sets of events that have already been annotated with a set of dispatched\n * listener functions/ids. The API is designed this way to discourage these\n * propagation strategies from actually executing the dispatches, since we\n * always want to collect the entire set of dispatches before executing event a\n * single one.\n *\n * @constructor EventPropagators\n */\nvar EventPropagators = {\n  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,\n  accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,\n  accumulateDirectDispatches: accumulateDirectDispatches,\n  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches\n};\n\nmodule.exports = EventPropagators;"],"mappings":"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"},"metadata":{},"sourceType":"script"}